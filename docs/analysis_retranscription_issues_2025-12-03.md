# Системный анализ: Проблемы ретранскрипции в AIWisper

**Дата:** 2025-12-03 15:30
**Статус:** Completed
**Аналитик:** @analyst

---

## Контекст и стейкхолдеры

### Роли/интересы/цели
- **Пользователь приложения**: хочет получить качественную транскрипцию записей с возможностью контроля процесса
- **Разработчик**: нуждается в понятной архитектуре для поддержки и расширения функционала

### Описание системы
AIWisper - десктопное приложение для записи и транскрипции аудио:
- **Frontend**: React/TypeScript + Electron
- **Backend**: Go (WebSocket API)
- **Транскрипция**: whisper.cpp (локально)
- **Режимы**: моно и стерео (раздельные каналы mic/sys)

---

## AS-IS (как сейчас)

### Проблема 1: Автоматический запуск ретранскрипции

**Локация:** `frontend/src/App.tsx`, строки 336-358

**Текущее поведение:**
```typescript
// Строка 149: настройка по умолчанию ВЫКЛЮЧЕНА
const [autoRetranscribe, setAutoRetranscribe] = useState(false);

// Строки 336-358: после session_stopped
if (autoRetranscribeRef.current && msg.session.id) {
    // Запускается retranscribe_full автоматически
}
```

**Анализ:**
- Это **ФИЧА**, не баг
- Настройка `autoRetranscribe` по умолчанию `false`
- Настройка сохраняется в `ipcRenderer.invoke('save-settings')` и загружается при старте
- Если пользователь жалуется на автозапуск - он сам включил эту опцию в настройках
- В UI есть чекбокс "Авто-распознавание" (строки 1156-1162)

**Вердикт:** Работает как задумано. Возможно, нужно улучшить UX - показывать уведомление при включении.

---

### Проблема 2: Нет кнопки отмены для ретранскрипции

**Локация:** `backend/main.go`, строки 1275-1707

**Текущее поведение:**
```go
// Строка 1306: горутина без возможности отмены
go func(sess *session.Session) {
    // ... длительная операция транскрипции
    // Нет проверки на отмену
}(sess)
```

**Проблемы:**
1. Горутина запускается без `context.Context`
2. Нет механизма отмены (cancel channel или context cancellation)
3. Нет WebSocket сообщения `cancel_full_transcription`
4. В UI нет кнопки отмены рядом с прогресс-баром (строки 1584-1619)

**Состояние UI при транскрипции:**
- Показывается прогресс-бар с процентами
- Кнопка ретранскрипции становится неактивной (`disabled={isFullTranscribing}`)
- Нет способа остановить процесс

---

### Проблема 3: Слияние сегментов при ретранскрипции

**Локация:** `backend/session/manager.go`, строки 691-801

**Текущее поведение:**
```go
// Строки 734-735: КРИТИЧНО - уничтожает структуру чанков
// Очищаем остальные чанки (они больше не нужны)
session.Chunks = []*Chunk{chunk}
```

**Что происходит:**
1. При полной ретранскрипции все сегменты объединяются в один "виртуальный" чанк
2. Все остальные чанки удаляются
3. Теряется информация о границах оригинальных чанков (StartMs, EndMs)
4. Теряется возможность ретранскрибировать отдельные чанки

**Структура Chunk (types.go):**
```go
type Chunk struct {
    StartMs  int64  // Границы в миллисекундах
    EndMs    int64
    MicSegments []TranscriptSegment
    SysSegments []TranscriptSegment
    Dialogue    []TranscriptSegment
}
```

**Последствия:**
- После полной ретранскрипции UI показывает только 1 чанк вместо N
- Невозможно перетранскрибировать отдельный фрагмент
- Потеря гранулярности данных

---

## TO-BE (как должно быть)

### Проблема 1: Автоматический запуск
**Статус:** Работает корректно, изменения не требуются.

**Рекомендация (опционально):**
- Добавить toast-уведомление при включении опции: "Полная транскрипция будет запускаться автоматически после каждой записи"

---

### Проблема 2: Кнопка отмены

**Целевое поведение:**
1. Пользователь может отменить полную ретранскрипцию в любой момент
2. При отмене сохраняется частичный результат (уже обработанные сегменты)
3. UI показывает кнопку отмены рядом с прогресс-баром

**Архитектурные требования:**
- Backend: использовать `context.Context` с cancellation
- WebSocket: новое сообщение `cancel_full_transcription`
- Frontend: кнопка отмены, обработка состояния отмены

---

### Проблема 3: Сохранение структуры чанков

**Целевое поведение:**
1. При полной ретранскрипции обновлять каждый чанк отдельно
2. Сохранять границы чанков (StartMs, EndMs)
3. Не объединять чанки в один

**Архитектурные требования:**
- Новый метод `UpdateChunkFullTranscription(sessionID, chunkID, micSegs, sysSegs)`
- Итерация по существующим чанкам вместо создания одного
- Сохранение метаданных каждого чанка отдельно

---

## Сценарии использования

### UC-1: Отмена полной ретранскрипции
**Основной поток:**
1. Пользователь запускает полную ретранскрипцию
2. Показывается прогресс-бар с кнопкой "Отмена"
3. Пользователь нажимает "Отмена"
4. Backend получает `cancel_full_transcription`
5. Горутина завершается, частичные результаты сохраняются
6. UI показывает уведомление "Транскрипция отменена"

**Альтернативный поток:**
- Если отмена во время обработки сегмента - дождаться завершения текущего сегмента

### UC-2: Полная ретранскрипция с сохранением чанков
**Основной поток:**
1. Пользователь запускает полную ретранскрипцию
2. Backend итерирует по существующим чанкам
3. Для каждого чанка: извлечение аудио -> транскрипция -> обновление
4. Прогресс отображается по чанкам (1/5, 2/5, ...)
5. После завершения все чанки обновлены, структура сохранена

---

## Глоссарий

| Термин | Определение |
|--------|-------------|
| Chunk | Фрагмент аудио с границами (StartMs, EndMs) и транскрипцией |
| Full Retranscription | Повторная транскрипция всего файла целиком |
| Segment | Единица транскрипции с таймстемпами (часть чанка) |
| VAD | Voice Activity Detection - определение речевой активности |
| Stereo Mode | Режим с раздельными каналами mic/sys |

---

## Качественные атрибуты (черновик)

### Производительность
- Полная ретранскрипция 1 часа записи: < 10 минут (зависит от модели)
- Отмена должна срабатывать в течение 2 секунд

### Надёжность
- При отмене не должны теряться уже обработанные данные
- При ошибке в одном чанке - продолжать обработку остальных

### Удобство использования
- Кнопка отмены должна быть заметной
- Прогресс должен показывать текущий чанк/сегмент

---

## Данные и интеграции

### Структуры данных
- `Session` - сессия записи с массивом `Chunks`
- `Chunk` - фрагмент с `StartMs`, `EndMs`, `MicSegments`, `SysSegments`, `Dialogue`
- `TranscriptSegment` - сегмент с `Start`, `End`, `Text`, `Speaker`

### Файловая структура сессии
```
sessions/{session_id}/
  meta.json          # Метаданные сессии
  full.mp3           # Полная запись
  summary.txt        # AI-summary (опционально)
  chunks/
    000.json         # Метаданные чанка 0
    001.json         # Метаданные чанка 1
    ...
```

### Владелец данных
- Backend (Go) - единственный источник истины
- Frontend получает данные через WebSocket

---

## Ограничения и предположения

### Ограничения
1. Whisper.cpp работает синхронно - нельзя прервать в середине транскрипции сегмента
2. Горутина должна проверять отмену между сегментами, не внутри
3. Частичные результаты должны быть валидными для отображения

### Предположения
1. Пользователь понимает, что отмена сохранит частичный результат
2. Структура чанков важна для пользователя (возможность ретранскрибировать отдельные фрагменты)

---

## Открытые вопросы и риски

| # | Вопрос/Риск | Приоритет | Действие |
|---|-------------|-----------|----------|
| 1 | Что делать с частичными результатами при отмене? | Высокий | Решение: сохранять обработанные чанки |
| 2 | Как обрабатывать ошибку в одном чанке? | Средний | Решение: пропускать, логировать, продолжать |
| 3 | Нужно ли уведомление при включении авто-ретранскрипции? | Низкий | Обсудить с UX |

---

## Приоритет и порядок исправлений

### Приоритет 1: Проблема 3 (Слияние чанков) - КРИТИЧНО
**Обоснование:** Потеря данных, невозможность работы с отдельными чанками
**Риск изменения:** Средний - требует рефакторинга `UpdateFullTranscription`
**Оценка:** 4-6 часов

### Приоритет 2: Проблема 2 (Кнопка отмены) - ВАЖНО
**Обоснование:** UX проблема, пользователь не может остановить длительную операцию
**Риск изменения:** Низкий - добавление нового функционала
**Оценка:** 3-4 часа

### Приоритет 3: Проблема 1 (Авто-запуск) - НЕ ТРЕБУЕТСЯ
**Обоснование:** Работает как задумано
**Действие:** Опционально добавить toast-уведомление

---

## Предложенные изменения в коде

### Проблема 3: Сохранение структуры чанков

**Файл:** `backend/session/manager.go`

**Изменение:** Заменить `UpdateFullTranscription` на версию, которая обновляет каждый чанк отдельно:

```go
// UpdateFullTranscription обновляет сессию с полной транскрипцией (стерео режим)
// Обновляет каждый чанк отдельно, сохраняя структуру
func (m *Manager) UpdateFullTranscription(sessionID string, chunkSegments map[string]ChunkTranscription) error {
    // chunkSegments: map[chunkID] -> {micSegments, sysSegments}
    // Итерируем по существующим чанкам и обновляем каждый
}
```

**Альтернатива (минимальные изменения):**
```go
// Вместо session.Chunks = []*Chunk{chunk}
// Обновляем каждый чанк с соответствующими сегментами
for _, chunk := range session.Chunks {
    // Фильтруем сегменты по StartMs/EndMs чанка
    chunkMicSegs := filterSegmentsByTimeRange(micSegments, chunk.StartMs, chunk.EndMs)
    chunkSysSegs := filterSegmentsByTimeRange(sysSegments, chunk.StartMs, chunk.EndMs)
    // Обновляем чанк
    chunk.MicSegments = chunkMicSegs
    chunk.SysSegments = chunkSysSegs
    chunk.Dialogue = mergeSegmentsToDialogue(chunkMicSegs, chunkSysSegs)
}
```

---

### Проблема 2: Механизм отмены

**Файл:** `backend/main.go`

**Изменения:**
1. Добавить map для хранения cancel functions:
```go
var fullTranscriptionCancels = make(map[string]context.CancelFunc)
var ftcMu sync.Mutex
```

2. Модифицировать обработчик `retranscribe_full`:
```go
case "retranscribe_full":
    ctx, cancel := context.WithCancel(context.Background())
    ftcMu.Lock()
    fullTranscriptionCancels[sess.ID] = cancel
    ftcMu.Unlock()
    
    go func(ctx context.Context, sess *session.Session) {
        defer func() {
            ftcMu.Lock()
            delete(fullTranscriptionCancels, sess.ID)
            ftcMu.Unlock()
        }()
        
        for segIdx, seg := range segments {
            // Проверка отмены перед каждым сегментом
            select {
            case <-ctx.Done():
                conn.WriteJSON(Message{
                    Type: "full_transcription_cancelled",
                    SessionID: sess.ID,
                })
                return
            default:
            }
            // ... обработка сегмента
        }
    }(ctx, sess)
```

3. Добавить обработчик отмены:
```go
case "cancel_full_transcription":
    ftcMu.Lock()
    if cancel, ok := fullTranscriptionCancels[msg.SessionID]; ok {
        cancel()
    }
    ftcMu.Unlock()
```

**Файл:** `frontend/src/App.tsx`

**Изменения:**
1. Добавить функцию отмены:
```typescript
const handleCancelFullTranscription = useCallback(() => {
    if (!selectedSession) return;
    wsRef.current?.send(JSON.stringify({
        type: 'cancel_full_transcription',
        sessionId: selectedSession.id
    }));
}, [selectedSession]);
```

2. Добавить кнопку в прогресс-бар (после строки 1618):
```tsx
<button
    onClick={handleCancelFullTranscription}
    style={{ /* стили */ }}
>
    Отмена
</button>
```

3. Добавить обработчик `full_transcription_cancelled` в switch.

---

## Хэндовер для @architect и @planner

### Ключевые артефакты
1. Анализ трёх проблем с ретранскрипцией
2. Приоритизация: P1 (чанки) > P2 (отмена) > P3 (не требуется)
3. Предложенные изменения в коде

### Области требующие особого внимания
1. **Проблема 3** требует изменения логики `UpdateFullTranscription` - нужно продумать обратную совместимость с существующими сессиями
2. **Проблема 2** требует добавления нового WebSocket сообщения и UI элемента

### Файлы для изменения
- `backend/session/manager.go` - UpdateFullTranscription
- `backend/main.go` - обработчики WebSocket
- `frontend/src/App.tsx` - UI и обработчики

### Оценка трудозатрат
- Проблема 3: 4-6 часов
- Проблема 2: 3-4 часа
- **Итого:** 7-10 часов разработки
