# Архитектура: AIWisper - Система записи и распознавания аудио

**Дата:** 2025-01-28 12:00
**Статус:** Draft
**Архитектор:** @architect

---

## ADR (Architecture Decision Record)

### Ключевые решения

| Решение | Альтернативы | Обоснование | Последствия |
|---------|--------------|-------------|-------------|
| Микширование аудио в реальном времени | Раздельные файлы для каждого канала | Упрощает воспроизведение, единый timeline | Потеря возможности раздельной обработки каналов |
| Streaming WAV writer | Буферизация всего в памяти | Поддержка длинных сессий (часы), crash-safety | Сложность обновления header |
| VAD на основе RMS + silence duration | WebRTC VAD, Silero VAD | Простота, низкая latency, уже реализовано | Менее точное определение речи |
| Worker pool для транскрипции | Последовательная обработка | Не блокирует запись, параллелизм | Сложность управления очередью |
| JSON metadata рядом с WAV | SQLite, единый JSON | Атомарность, простота, нет зависимостей | Много мелких файлов |
| HTTP + WebSocket | Только WebSocket | REST для файлов, WS для real-time | Два протокола |

---

## Архитектурные диаграммы

### Container Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Frontend (React + Vite)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────────────┐ │
│  │   Controls   │  │   Waveform   │  │  Recording List + Player   │ │
│  │  start/stop  │  │  audio level │  │  list, play, re-transcribe │ │
│  └──────┬───────┘  └──────┬───────┘  └─────────────┬──────────────┘ │
└─────────┼─────────────────┼────────────────────────┼─────────────────┘
          │                 │                        │
          │ WebSocket       │ WebSocket              │ HTTP GET
          │ commands        │ levels                 │ /api/sessions/*
          ▼                 ▼                        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         Go Backend (:8080)                           │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                      HTTP/WebSocket Server                      │ │
│  │  /ws              - WebSocket handler                           │ │
│  │  /api/sessions    - REST API for sessions                       │ │
│  │  /api/files/*     - Static file serving                         │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                              │                                       │
│  ┌───────────────────────────┴────────────────────────────────────┐ │
│  │                      SessionManager                             │ │
│  │  - CreateSession() / StopSession() / GetSession() / List()     │ │
│  └───────────────────────────┬────────────────────────────────────┘ │
│                              │                                       │
│  ┌───────────────────────────┴────────────────────────────────────┐ │
│  │                      AudioPipeline                              │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ │ │
│  │  │ AudioMixer  │  │ WAVWriter   │  │ ChunkBuffer (VAD)       │ │ │
│  │  │ mic+system  │─▶│ full.wav    │  │ detect pauses, emit     │ │ │
│  │  └─────────────┘  └─────────────┘  └───────────┬─────────────┘ │ │
│  └────────────────────────────────────────────────┼────────────────┘ │
│                                                   │                  │
│  ┌────────────────────────────────────────────────┴────────────────┐ │
│  │                      ChunkManager                               │ │
│  │  - SaveChunk() -> chunk_{n}.wav                                 │ │
│  │  - Queue for transcription                                      │ │
│  └────────────────────────────────────────────────┬────────────────┘ │
│                                                   │                  │
│  ┌────────────────────────────────────────────────┴────────────────┐ │
│  │                   TranscriptionWorkerPool                       │ │
│  │  - N workers (default: 2)                                       │ │
│  │  - Process chunks in parallel                                   │ │
│  └────────────────────────────────────────────────┬────────────────┘ │
│                                                   │                  │
│  ┌────────────────────────────────────────────────┴────────────────┐ │
│  │                      Whisper Engine                             │ │
│  │  - whisper.cpp binding (ggml models)                            │ │
│  │  - faster-whisper fallback (Python CLI)                         │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                      Audio Capture                              │ │
│  │  ┌─────────────────┐  ┌─────────────────────────────────────┐  │ │
│  │  │ Microphone      │  │ System Audio                        │  │ │
│  │  │ (malgo)         │  │ (ScreenCaptureKit / BlackHole)      │  │ │
│  │  └─────────────────┘  └─────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────┐
│                         File System                                   │
│  data/sessions/{session-id}/                                         │
│    ├── meta.json                                                     │
│    ├── full.wav                                                      │
│    └── chunks/                                                       │
│        ├── 000.wav, 000.json                                         │
│        ├── 001.wav, 001.json                                         │
│        └── ...                                                       │
└──────────────────────────────────────────────────────────────────────┘
```

### Sequence Diagram: Запись сессии

```
Frontend          WebSocket         SessionMgr       AudioPipeline      ChunkMgr        Whisper
    │                 │                 │                 │                │               │
    │──start_session─▶│                 │                 │                │               │
    │                 │──CreateSession─▶│                 │                │               │
    │                 │                 │──StartPipeline─▶│                │               │
    │                 │                 │                 │                │               │
    │◀─session_started│                 │                 │                │               │
    │                 │                 │                 │                │               │
    │                 │                 │     [Audio samples arrive]      │               │
    │                 │                 │                 │                │               │
    │                 │                 │    ┌───────────┐│                │               │
    │                 │                 │    │Mix samples││                │               │
    │                 │                 │    │Write WAV  ││                │               │
    │                 │                 │    │VAD detect ││                │               │
    │                 │                 │    └───────────┘│                │               │
    │                 │                 │                 │                │               │
    │◀──audio_level───│                 │◀───level_data──│                │               │
    │                 │                 │                 │                │               │
    │                 │                 │     [Pause detected - emit chunk]│               │
    │                 │                 │                 │──SaveChunk────▶│               │
    │                 │                 │                 │                │──Transcribe──▶│
    │◀─chunk_created──│                 │                 │                │               │
    │                 │                 │                 │                │◀──result──────│
    │◀chunk_transcribed                 │                 │◀───update──────│               │
    │                 │                 │                 │                │               │
    │──stop_session──▶│                 │                 │                │               │
    │                 │──StopSession───▶│                 │                │               │
    │                 │                 │──StopPipeline──▶│                │               │
    │                 │                 │                 │──Finalize WAV─▶│               │
    │◀─session_stopped│                 │                 │                │               │
```

### ERD / Схема данных

```
┌─────────────────────────────────────┐
│              Session                │
├─────────────────────────────────────┤
│ ID          string (UUID)      PK   │
│ StartTime   time.Time               │
│ EndTime     *time.Time              │
│ Status      SessionStatus           │
│ Language    string                  │
│ Model       string                  │
│ DataDir     string                  │
│ TotalDuration time.Duration         │
│ SampleCount int64                   │
├─────────────────────────────────────┤
│ Chunks      []Chunk            1:N  │
└─────────────────────────────────────┘
              │
              │ 1:N
              ▼
┌─────────────────────────────────────┐
│               Chunk                 │
├─────────────────────────────────────┤
│ ID          string (UUID)      PK   │
│ SessionID   string             FK   │
│ Index       int                     │
│ StartOffset int64 (samples)         │
│ EndOffset   int64 (samples)         │
│ Duration    time.Duration           │
│ FilePath    string                  │
│ Status      ChunkStatus             │
│ Transcription string                │
│ Source      AudioSource             │
│ CreatedAt   time.Time               │
│ TranscribedAt *time.Time            │
└─────────────────────────────────────┘

Enums:
- SessionStatus: recording, completed, failed
- ChunkStatus: pending, transcribing, completed, failed  
- AudioSource: mic, system, mixed
```

---

## Go Структуры данных

```go
// === session/types.go ===

package session

import (
    "sync"
    "time"
)

// SessionStatus представляет состояние сессии
type SessionStatus string

const (
    SessionStatusRecording SessionStatus = "recording"
    SessionStatusCompleted SessionStatus = "completed"
    SessionStatusFailed    SessionStatus = "failed"
)

// ChunkStatus представляет состояние чанка
type ChunkStatus string

const (
    ChunkStatusPending     ChunkStatus = "pending"
    ChunkStatusTranscribing ChunkStatus = "transcribing"
    ChunkStatusCompleted   ChunkStatus = "completed"
    ChunkStatusFailed      ChunkStatus = "failed"
)

// AudioSource представляет источник аудио
type AudioSource string

const (
    AudioSourceMic    AudioSource = "mic"
    AudioSourceSystem AudioSource = "system"
    AudioSourceMixed  AudioSource = "mixed"
)

// Session представляет сессию записи
type Session struct {
    ID            string        `json:"id"`
    StartTime     time.Time     `json:"startTime"`
    EndTime       *time.Time    `json:"endTime,omitempty"`
    Status        SessionStatus `json:"status"`
    Language      string        `json:"language"`
    Model         string        `json:"model"`
    DataDir       string        `json:"dataDir"`
    TotalDuration time.Duration `json:"totalDuration"`
    SampleCount   int64         `json:"sampleCount"`
    
    Chunks        []*Chunk      `json:"chunks"`
    
    mu            sync.RWMutex  `json:"-"`
}

// Chunk представляет фрагмент аудио для распознавания
type Chunk struct {
    ID            string        `json:"id"`
    SessionID     string        `json:"sessionId"`
    Index         int           `json:"index"`
    StartOffset   int64         `json:"startOffset"`   // в семплах
    EndOffset     int64         `json:"endOffset"`     // в семплах
    Duration      time.Duration `json:"duration"`
    FilePath      string        `json:"filePath"`
    Status        ChunkStatus   `json:"status"`
    Transcription string        `json:"transcription,omitempty"`
    Source        AudioSource   `json:"source"`
    CreatedAt     time.Time     `json:"createdAt"`
    TranscribedAt *time.Time    `json:"transcribedAt,omitempty"`
    Error         string        `json:"error,omitempty"`
}

// SessionConfig конфигурация для создания сессии
type SessionConfig struct {
    Language      string
    Model         string
    MicDevice     string
    SystemDevice  string
    CaptureSystem bool
    UseNative     bool  // ScreenCaptureKit
}

// VADConfig конфигурация Voice Activity Detection
type VADConfig struct {
    SilenceThreshold  float64       // RMS порог (default: 0.008)
    SilenceDuration   time.Duration // Длительность тишины для разделения (default: 300ms)
    MinChunkDuration  time.Duration // Минимальная длина чанка (default: 1s)
    MaxChunkDuration  time.Duration // Максимальная длина чанка (default: 15s)
    PreRollDuration   time.Duration // Буфер до начала речи (default: 500ms)
}

// DefaultVADConfig возвращает конфигурацию VAD по умолчанию
func DefaultVADConfig() VADConfig {
    return VADConfig{
        SilenceThreshold: 0.008,
        SilenceDuration:  300 * time.Millisecond,
        MinChunkDuration: 1 * time.Second,
        MaxChunkDuration: 15 * time.Second,
        PreRollDuration:  500 * time.Millisecond,
    }
}
```

```go
// === session/manager.go ===

package session

import (
    "fmt"
    "os"
    "path/filepath"
    "sync"
    "time"
    
    "github.com/google/uuid"
)

// Manager управляет сессиями записи
type Manager struct {
    sessions    map[string]*Session
    activeID    string  // ID текущей активной сессии
    dataDir     string
    mu          sync.RWMutex
    
    // Callbacks
    onChunkReady      func(chunk *Chunk)
    onChunkTranscribed func(chunk *Chunk)
}

// NewManager создаёт новый менеджер сессий
func NewManager(dataDir string) (*Manager, error)

// CreateSession создаёт новую сессию записи
func (m *Manager) CreateSession(cfg SessionConfig) (*Session, error)

// StopSession останавливает активную сессию
func (m *Manager) StopSession() (*Session, error)

// GetSession возвращает сессию по ID
func (m *Manager) GetSession(id string) (*Session, error)

// GetActiveSession возвращает текущую активную сессию
func (m *Manager) GetActiveSession() *Session

// ListSessions возвращает список всех сессий
func (m *Manager) ListSessions() []*Session

// DeleteSession удаляет сессию и её файлы
func (m *Manager) DeleteSession(id string) error

// AddChunk добавляет чанк к сессии
func (m *Manager) AddChunk(sessionID string, chunk *Chunk) error

// UpdateChunkTranscription обновляет транскрипцию чанка
func (m *Manager) UpdateChunkTranscription(sessionID, chunkID, text string) error

// SetOnChunkReady устанавливает callback для готовых чанков
func (m *Manager) SetOnChunkReady(fn func(chunk *Chunk))

// SetOnChunkTranscribed устанавливает callback для распознанных чанков
func (m *Manager) SetOnChunkTranscribed(fn func(chunk *Chunk))

// LoadSessions загружает сессии с диска при старте
func (m *Manager) LoadSessions() error

// SaveSessionMeta сохраняет метаданные сессии
func (m *Manager) SaveSessionMeta(s *Session) error
```

```go
// === audio/mixer.go ===

package audio

import (
    "sync"
    "time"
)

// MixedSample представляет смикшированный семпл
type MixedSample struct {
    Sample    float32
    Timestamp time.Time
    HasMic    bool
    HasSystem bool
}

// AudioMixer микширует аудио из двух источников
type AudioMixer struct {
    micBuffer    *TimestampedBuffer
    systemBuffer *TimestampedBuffer
    outputChan   chan []float32
    
    sampleRate   int
    bufferSize   int
    
    mu           sync.Mutex
    running      bool
}

// NewAudioMixer создаёт новый микшер
func NewAudioMixer(sampleRate, bufferSize int) *AudioMixer

// Start запускает микширование
func (m *AudioMixer) Start() error

// Stop останавливает микширование
func (m *AudioMixer) Stop()

// AddMicSamples добавляет семплы с микрофона
func (m *AudioMixer) AddMicSamples(samples []float32, timestamp time.Time)

// AddSystemSamples добавляет семплы системного звука
func (m *AudioMixer) AddSystemSamples(samples []float32, timestamp time.Time)

// Output возвращает канал с микшированными семплами
func (m *AudioMixer) Output() <-chan []float32

// TimestampedBuffer буфер с временными метками для синхронизации
type TimestampedBuffer struct {
    samples   []float32
    startTime time.Time
    endTime   time.Time
    mu        sync.Mutex
}
```

```go
// === audio/wav_writer.go ===

package audio

import (
    "os"
    "sync"
)

// WAVWriter потоковый писатель WAV файлов
type WAVWriter struct {
    file        *os.File
    filePath    string
    sampleRate  int
    channels    int
    bitsPerSample int
    
    samplesWritten int64
    headerWritten  bool
    
    mu          sync.Mutex
}

// NewWAVWriter создаёт новый WAV writer
func NewWAVWriter(filePath string, sampleRate, channels, bitsPerSample int) (*WAVWriter, error)

// Write записывает семплы в файл
func (w *WAVWriter) Write(samples []float32) error

// WritePCM16 записывает PCM16 данные напрямую
func (w *WAVWriter) WritePCM16(data []byte) error

// SamplesWritten возвращает количество записанных семплов
func (w *WAVWriter) SamplesWritten() int64

// Duration возвращает длительность записи
func (w *WAVWriter) Duration() time.Duration

// Finalize завершает запись и обновляет header
func (w *WAVWriter) Finalize() error

// Close закрывает файл (вызывает Finalize если нужно)
func (w *WAVWriter) Close() error
```

```go
// === audio/chunk_buffer.go ===

package audio

import (
    "time"
)

// ChunkEvent событие готовности чанка
type ChunkEvent struct {
    Samples     []float32
    StartOffset int64  // смещение от начала сессии в семплах
    EndOffset   int64
    Duration    time.Duration
}

// ChunkBuffer буфер для VAD и нарезки на чанки
type ChunkBuffer struct {
    config      VADConfig
    sampleRate  int
    
    preRoll     *RingBuffer  // буфер до начала речи
    current     []float32    // текущий накапливаемый чанк
    
    isSpeaking  bool
    lastSpeechTime time.Time
    chunkStartOffset int64
    totalSamples int64
    
    outputChan  chan ChunkEvent
}

// NewChunkBuffer создаёт новый буфер для чанков
func NewChunkBuffer(config VADConfig, sampleRate int) *ChunkBuffer

// Process обрабатывает входящие семплы
func (b *ChunkBuffer) Process(samples []float32) 

// Output возвращает канал с готовыми чанками
func (b *ChunkBuffer) Output() <-chan ChunkEvent

// Flush принудительно выдаёт текущий буфер как чанк
func (b *ChunkBuffer) Flush() *ChunkEvent

// Reset сбрасывает состояние буфера
func (b *ChunkBuffer) Reset()

// RingBuffer кольцевой буфер для pre-roll
type RingBuffer struct {
    data     []float32
    capacity int
    start    int
    length   int
}

// NewRingBuffer создаёт кольцевой буфер
func NewRingBuffer(capacity int) *RingBuffer

// Write добавляет данные в буфер
func (r *RingBuffer) Write(samples []float32)

// Read читает все данные из буфера
func (r *RingBuffer) Read() []float32

// Clear очищает буфер
func (r *RingBuffer) Clear()
```

```go
// === audio/pipeline.go ===

package audio

import (
    "sync"
)

// PipelineConfig конфигурация аудио пайплайна
type PipelineConfig struct {
    SessionDir    string
    SampleRate    int
    VADConfig     VADConfig
    MixChannels   bool  // микшировать каналы или обрабатывать раздельно
}

// Pipeline управляет потоком аудио данных
type Pipeline struct {
    config      PipelineConfig
    
    mixer       *AudioMixer
    wavWriter   *WAVWriter
    chunkBuffer *ChunkBuffer
    
    levelChan   chan AudioLevelEvent
    chunkChan   chan ChunkEvent
    
    mu          sync.Mutex
    running     bool
}

// AudioLevelEvent событие уровня громкости
type AudioLevelEvent struct {
    MicLevel    float64
    SystemLevel float64
    MixedLevel  float64
    Timestamp   time.Time
}

// NewPipeline создаёт новый пайплайн
func NewPipeline(config PipelineConfig) (*Pipeline, error)

// Start запускает пайплайн
func (p *Pipeline) Start() error

// Stop останавливает пайплайн
func (p *Pipeline) Stop() error

// ProcessMicSamples обрабатывает семплы с микрофона
func (p *Pipeline) ProcessMicSamples(samples []float32)

// ProcessSystemSamples обрабатывает семплы системного звука
func (p *Pipeline) ProcessSystemSamples(samples []float32)

// Levels возвращает канал с уровнями громкости
func (p *Pipeline) Levels() <-chan AudioLevelEvent

// Chunks возвращает канал с готовыми чанками
func (p *Pipeline) Chunks() <-chan ChunkEvent

// TotalSamples возвращает общее количество записанных семплов
func (p *Pipeline) TotalSamples() int64
```

```go
// === transcribe/worker.go ===

package transcribe

import (
    "context"
    "sync"
)

// Job задание на транскрипцию
type Job struct {
    ChunkID     string
    SessionID   string
    FilePath    string
    Language    string
    Model       string
}

// Result результат транскрипции
type Result struct {
    ChunkID   string
    SessionID string
    Text      string
    Error     error
    Duration  time.Duration
}

// WorkerPool пул воркеров для транскрипции
type WorkerPool struct {
    engine      *ai.Engine
    workers     int
    jobChan     chan Job
    resultChan  chan Result
    
    ctx         context.Context
    cancel      context.CancelFunc
    wg          sync.WaitGroup
}

// NewWorkerPool создаёт пул воркеров
func NewWorkerPool(engine *ai.Engine, workers int) *WorkerPool

// Start запускает воркеры
func (p *WorkerPool) Start()

// Stop останавливает воркеры
func (p *WorkerPool) Stop()

// Submit отправляет задание на транскрипцию
func (p *WorkerPool) Submit(job Job)

// Results возвращает канал с результатами
func (p *WorkerPool) Results() <-chan Result
```

---

## API Контракты

### WebSocket Messages (Client -> Server)

```typescript
// Начать новую сессию записи
interface StartSessionMessage {
    type: "start_session";
    language: string;        // "ru", "en", "auto"
    model: string;           // путь к модели
    micDevice?: string;      // ID микрофона
    systemDevice?: string;   // ID устройства системного звука
    captureSystem: boolean;  // захватывать системный звук
    useNativeCapture: boolean; // использовать ScreenCaptureKit
}

// Остановить текущую сессию
interface StopSessionMessage {
    type: "stop_session";
}

// Получить список сессий
interface GetSessionsMessage {
    type: "get_sessions";
    limit?: number;
    offset?: number;
}

// Получить детали сессии
interface GetSessionMessage {
    type: "get_session";
    sessionId: string;
}

// Перераспознать чанк
interface RetranscribeChunkMessage {
    type: "retranscribe_chunk";
    sessionId: string;
    chunkId: string;
    language?: string;  // опционально изменить язык
    model?: string;     // опционально изменить модель
}

// Удалить сессию
interface DeleteSessionMessage {
    type: "delete_session";
    sessionId: string;
}

// Получить список устройств
interface GetDevicesMessage {
    type: "get_devices";
}
```

### WebSocket Messages (Server -> Client)

```typescript
// Сессия началась
interface SessionStartedMessage {
    type: "session_started";
    session: Session;
}

// Сессия остановлена
interface SessionStoppedMessage {
    type: "session_stopped";
    session: Session;
}

// Новый чанк создан
interface ChunkCreatedMessage {
    type: "chunk_created";
    sessionId: string;
    chunk: Chunk;
}

// Чанк распознан
interface ChunkTranscribedMessage {
    type: "chunk_transcribed";
    sessionId: string;
    chunk: Chunk;
}

// Уровень громкости
interface AudioLevelMessage {
    type: "audio_level";
    mic: number;      // 0.0 - 1.0
    system: number;   // 0.0 - 1.0
    mixed: number;    // 0.0 - 1.0
}

// Список сессий
interface SessionsListMessage {
    type: "sessions_list";
    sessions: SessionSummary[];
    total: number;
}

// Детали сессии
interface SessionDetailsMessage {
    type: "session_details";
    session: Session;
}

// Список устройств
interface DevicesMessage {
    type: "devices";
    devices: AudioDevice[];
    screenCaptureKitAvailable: boolean;
}

// Ошибка
interface ErrorMessage {
    type: "error";
    code: string;
    message: string;
}
```

### HTTP REST API

```yaml
openapi: 3.0.0
info:
  title: AIWisper API
  version: 1.0.0

paths:
  /api/sessions:
    get:
      summary: Список сессий
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
        - name: offset
          in: query
          schema:
            type: integer
            default: 0
      responses:
        200:
          description: Список сессий
          content:
            application/json:
              schema:
                type: object
                properties:
                  sessions:
                    type: array
                    items:
                      $ref: '#/components/schemas/SessionSummary'
                  total:
                    type: integer

  /api/sessions/{sessionId}:
    get:
      summary: Детали сессии
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          description: Детали сессии
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Session'
        404:
          description: Сессия не найдена

    delete:
      summary: Удалить сессию
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
      responses:
        204:
          description: Сессия удалена
        404:
          description: Сессия не найдена

  /api/sessions/{sessionId}/full.wav:
    get:
      summary: Скачать полную запись
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: WAV файл
          content:
            audio/wav:
              schema:
                type: string
                format: binary
        404:
          description: Файл не найден

  /api/sessions/{sessionId}/chunks/{chunkIndex}.wav:
    get:
      summary: Скачать чанк
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
        - name: chunkIndex
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: WAV файл чанка
          content:
            audio/wav:
              schema:
                type: string
                format: binary

  /api/sessions/{sessionId}/chunks/{chunkId}/retranscribe:
    post:
      summary: Перераспознать чанк
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
        - name: chunkId
          in: path
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                language:
                  type: string
                model:
                  type: string
      responses:
        202:
          description: Задание принято
        404:
          description: Чанк не найден

components:
  schemas:
    Session:
      type: object
      properties:
        id:
          type: string
          format: uuid
        startTime:
          type: string
          format: date-time
        endTime:
          type: string
          format: date-time
          nullable: true
        status:
          type: string
          enum: [recording, completed, failed]
        language:
          type: string
        model:
          type: string
        totalDuration:
          type: integer
          description: Длительность в миллисекундах
        chunks:
          type: array
          items:
            $ref: '#/components/schemas/Chunk'

    SessionSummary:
      type: object
      properties:
        id:
          type: string
        startTime:
          type: string
          format: date-time
        status:
          type: string
        totalDuration:
          type: integer
        chunksCount:
          type: integer

    Chunk:
      type: object
      properties:
        id:
          type: string
        index:
          type: integer
        duration:
          type: integer
          description: Длительность в миллисекундах
        status:
          type: string
          enum: [pending, transcribing, completed, failed]
        transcription:
          type: string
        source:
          type: string
          enum: [mic, system, mixed]
        createdAt:
          type: string
          format: date-time

    AudioDevice:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        isInput:
          type: boolean
        isOutput:
          type: boolean
```

---

## Структура файлов на диске

```
data/
└── sessions/
    └── {session-uuid}/
        ├── meta.json              # Метаданные сессии
        ├── full.wav               # Полная запись (16kHz, mono, PCM16)
        └── chunks/
            ├── 000.wav            # Чанк 0
            ├── 000.json           # Метаданные чанка 0
            ├── 001.wav            # Чанк 1
            ├── 001.json           # Метаданные чанка 1
            └── ...
```

### meta.json (сессия)

```json
{
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "startTime": "2025-01-28T12:00:00Z",
    "endTime": "2025-01-28T12:30:00Z",
    "status": "completed",
    "language": "ru",
    "model": "ggml-base.bin",
    "totalDuration": 1800000,
    "sampleCount": 28800000,
    "chunksCount": 120
}
```

### {index}.json (чанк)

```json
{
    "id": "660e8400-e29b-41d4-a716-446655440001",
    "sessionId": "550e8400-e29b-41d4-a716-446655440000",
    "index": 0,
    "startOffset": 0,
    "endOffset": 192000,
    "duration": 12000,
    "status": "completed",
    "transcription": "Привет, это тестовая запись.",
    "source": "mixed",
    "createdAt": "2025-01-28T12:00:12Z",
    "transcribedAt": "2025-01-28T12:00:15Z"
}
```

---

## Нефункциональные требования

### Производительность

| Метрика | Целевое значение | Бюджет |
|---------|------------------|--------|
| Latency записи (семпл -> диск) | < 50ms | P99 < 100ms |
| Latency VAD (детекция паузы) | < 100ms | P99 < 200ms |
| Транскрипция чанка (15s, base) | < 5s | P99 < 10s |
| Транскрипция чанка (15s, large) | < 15s | P99 < 30s |
| Memory usage (idle) | < 200MB | < 500MB |
| Memory usage (recording) | < 500MB | < 1GB |
| CPU usage (recording) | < 30% | < 50% |

### Надёжность

| Требование | Реализация |
|------------|------------|
| WAV валиден при crash | Периодический flush header (каждые 10s) |
| Атомарность чанков | Write to temp file, then rename |
| Восстановление после restart | Загрузка meta.json при старте |
| Graceful shutdown | Finalize WAV, save pending chunks |

### Масштабируемость

| Параметр | Лимит |
|----------|-------|
| Максимальная длительность сессии | 4 часа |
| Максимум чанков на сессию | 2000 |
| Максимум параллельных транскрипций | 4 (configurable) |
| Размер WAV файла (4 часа, 16kHz mono) | ~460MB |

### Безопасность

- Файлы доступны только через API (не прямой доступ к файловой системе)
- Валидация session ID (UUID format)
- Rate limiting на API endpoints
- Санитизация путей (предотвращение path traversal)

---

## Observability

### Логирование

```go
// Уровни логов
// INFO: старт/стоп сессии, создание чанка, завершение транскрипции
// DEBUG: VAD events, audio levels, buffer states
// WARN: dropped frames, slow transcription
// ERROR: file I/O errors, transcription failures

// Структура лога
type LogEntry struct {
    Timestamp time.Time `json:"ts"`
    Level     string    `json:"level"`
    Message   string    `json:"msg"`
    SessionID string    `json:"session_id,omitempty"`
    ChunkID   string    `json:"chunk_id,omitempty"`
    Duration  int64     `json:"duration_ms,omitempty"`
    Error     string    `json:"error,omitempty"`
}
```

### Метрики (для будущего Prometheus)

```
# Счётчики
aiwisper_sessions_total{status="completed|failed"}
aiwisper_chunks_total{status="completed|failed"}
aiwisper_transcriptions_total{model="base|small|medium|large"}

# Гистограммы
aiwisper_chunk_duration_seconds
aiwisper_transcription_duration_seconds{model}
aiwisper_wav_write_latency_seconds

# Gauges
aiwisper_active_sessions
aiwisper_pending_transcriptions
aiwisper_audio_buffer_samples
```

---

## Архитектурные риски

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Рассинхронизация mic/system audio | Medium | Medium | Timestamp-based sync в AudioMixer, допуск ±50ms |
| Переполнение памяти при длинных сессиях | Low | High | Streaming write, ограничение буферов |
| Блокировка записи при медленной транскрипции | Medium | High | Worker pool, async processing |
| Потеря данных при crash | Medium | High | Periodic WAV header flush, atomic chunk writes |
| Некорректный VAD (режет слова) | Medium | Medium | Настраиваемые параметры, pre-roll buffer |

---

## Рекомендации для реализации

### Для @planner

**Области для декомпозиции:**
1. **Phase 1: Core Recording** (приоритет: высокий)
   - SessionManager с базовым CRUD
   - WAVWriter с streaming записью
   - Интеграция с существующим audio capture

2. **Phase 2: Chunking** (приоритет: высокий)
   - ChunkBuffer с VAD
   - ChunkManager для сохранения
   - Интеграция с TranscriptionWorkerPool

3. **Phase 3: API & UI** (приоритет: средний)
   - HTTP endpoints для файлов
   - WebSocket protocol расширение
   - UI компоненты (список записей, плеер)

4. **Phase 4: Polish** (приоритет: низкий)
   - AudioMixer для синхронизации каналов
   - Метрики и observability
   - Оптимизация производительности

### Для @coder

**Conventions:**
- Использовать существующую структуру пакетов (`audio/`, `ai/`)
- Добавить новый пакет `session/` для управления сессиями
- Добавить пакет `transcribe/` для worker pool
- Сохранить совместимость с текущим WebSocket протоколом

**Шаблоны:**
- Error handling: wrap errors с контекстом
- Concurrency: channels для коммуникации, mutex для shared state
- File I/O: defer close, atomic writes

### Для @tester

**Ключевые сценарии:**
1. Запись сессии 5 минут -> проверка WAV валидности
2. VAD корректно разделяет речь на чанки
3. Crash recovery: WAV читаем после kill -9
4. Параллельная транскрипция не блокирует запись
5. HTTP API возвращает корректные файлы
6. WebSocket reconnect сохраняет состояние

**NFR для проверки:**
- Latency записи < 50ms (измерить timestamp diff)
- Memory не растёт линейно с длительностью сессии
- CPU < 50% при записи + транскрипции
